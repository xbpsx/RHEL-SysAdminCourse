**Веб-сервер** — это идеальная иллюстрация параллельной работы. Давайте разберем его в том же формате.

## Что такое веб-сервер?

### Простыми словами (Как для ресторана):

Представьте, что **веб-сервер** — это большой ресторан:

- **Клиенты (браузеры)** — это посетители, которые приходят за едой (веб-страницами)

- **Повара (worker processes)** — готовят блюда (обрабатывают запросы)

- **Менеджер (master process)** — распределяет заказы между поварами

- **Кухня (память)** — где хранятся ингредиенты (файлы, данные)

- **Поваренная книга (код)** — рецепты приготовления блюд

**Как это работает:**  
Один посетитель заказывает суп, другой — стейк, третий — салат. Ресторан не заставляет всех ждать, пока приготовят суп, а готовит все блюда параллельно разными поварами.

### Более технически:

**Веб-сервер** — это программа, которая принимает HTTP-запросы от клиентов (браузеров, мобильных приложений) и возвращает HTTP-ответы (HTML-страницы, изображения, данные).

### Архитектура веб-сервера:

```text
Master Process (Родительский процесс)
    ├── Worker Process 1 (Обрабатывает запрос пользователя A)
    ├── Worker Process 2 (Обрабатывает запрос пользователя B) 
    ├── Worker Process 3 (Обрабатывает запрос пользователя C)
    └── Worker Process N (Обрабатывает запрос пользователя N)
```

### Практический пример с Nginx:

```bash
# Просмотр процессов nginx
ps aux | grep nginx
```

**Вывод:**

```text
root      1234  0.0  0.1  10000  2000 ?        Ss   10:00   0:00 nginx: master process
www-data  1235  0.1  0.5  15000  8000 ?        S    10:00   0:05 nginx: worker process
www-data  1236  0.1  0.5  15000  8000 ?        S    10:00   0:05 nginx: worker process
www-data  1237  0.1  0.5  15000  8000 ?        S    10:00   0:05 nginx: worker process
www-data  1238  0.1  0.5  15000  8000 ?        S    10:00   0:05 nginx: worker process
```

## Для системного администратора веб-сервер — это:

### 1. **Критический сервис, требующий мониторинга**

```bash
# Проверка статуса веб-сервера
systemctl status nginx
systemctl status apache2

# Проверка портов
netstat -tulpn | grep :80
ss -tulpn | grep :80

# Проверка логов в реальном времени
tail -f /var/log/nginx/access.log
tail -f /var/log/nginx/error.log
```

### 2. **Объект настройки и оптимизации**

```bash
# Конфигурационные файлы
/etc/nginx/nginx.conf
/etc/nginx/sites-available/
/etc/apache2/apache2.conf
```

### 3. **Источник проблем с производительностью**

## Практическая работа с веб-серверами для системного администратора

### Мониторинг производительности:

```bash
# Количество активных подключений
netstat -an | grep :80 | wc -l

# Статистика nginx
nginx -T  # показать всю конфигурацию

# Apache status (если включен mod_status)
curl http://localhost/server-status
```

### Анализ нагрузки:

```bash
# Топ IP-адресов по количеству запросов
awk '{print $1}' /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -10

# Самые популярные URL
awk '{print $7}' /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -10

# Статусы ответов
awk '{print $9}' /var/log/nginx/access.log | sort | uniq -c | sort -nr
```

### Практические сценарии для админа:

**Сценарий 1: Мониторинг здоровья веб-сервера**

```bash
#!/bin/bash
# web_server_health_check.sh

SERVER="localhost"
PORT="80"
MAX_CONNECTIONS=1000

# Проверка доступности
if ! curl -s --head "http://$SERVER:$PORT" > /dev/null; then
    echo "CRITICAL: Web server is down!"
    systemctl restart nginx
    exit 1
fi

# Проверка количества соединений
CURRENT_CONNECTIONS=$(netstat -an | grep :$PORT | grep ESTABLISHED | wc -l)

if [ $CURRENT_CONNECTIONS -gt $MAX_CONNECTIONS ]; then
    echo "WARNING: High connection count: $CURRENT_CONNECTIONS"
    
    # Анализ того, кто создает нагрузку
    echo "Top IP addresses:"
    netstat -an | grep :$PORT | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr | head -5
fi

echo "OK: Web server is healthy. Connections: $CURRENT_CONNECTIONS"
```

**Сценарий 2: Автоматическое реагирование на высокую нагрузку**

```bash
#!/bin/bash
# web_server_autoscale.sh

LOAD_THRESHOLD=80
CURRENT_LOAD=$(awk '{print $1}' /proc/loadavg | cut -d. -f1)

if [ $CURRENT_LOAD -gt $LOAD_THRESHOLD ]; then
    echo "High load detected: $CURRENT_LOAD"
    
    # Увеличиваем количество worker processes в nginx
    CURRENT_WORKERS=$(grep worker_processes /etc/nginx/nginx.conf | awk '{print $2}' | tr -d ';')
    NEW_WORKERS=$((CURRENT_WORKERS * 2))
    
    # Бэкап конфига и изменение
    cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.backup.$(date +%Y%m%d_%H%M%S)
    sed -i "s/worker_processes $CURRENT_WORKERS;/worker_processes $NEW_WORKERS;/" /etc/nginx/nginx.conf
    
    # Проверка конфигурации и перезагрузка
    if nginx -t; then
        systemctl reload nginx
        echo "Increased worker processes from $CURRENT_WORKERS to $NEW_WORKERS"
    else
        echo "Error in nginx configuration. Rolling back."
        cp /etc/nginx/nginx.conf.backup.* /etc/nginx/nginx.conf
    fi
fi
```

**Сценарий 3: Анализ медленных запросов**

```bash
#!/bin/bash
# slow_requests_analysis.sh

LOG_FILE="/var/log/nginx/access.log"
SLOW_THRESHOLD=5  # seconds

echo "=== Запросы дольше ${SLOW_THRESHOLD} секунд ==="

# Если в логе есть время обработки (обычно в $request_time)
awk -v threshold=$SLOW_THRESHOLD '$NF > threshold {print $7, $NF "s", $1}' $LOG_FILE | \
sort -k2 -nr | \
head -20

echo -e "\n=== Самые частые медленные endpoints ==="
awk -v threshold=$SLOW_THRESHOLD '$NF > threshold {print $7}' $LOG_FILE | \
sort | \
uniq -c | \
sort -nr | \
head -10
```

**Сценарий 4: Базовая защита от DDoS**

```bash
#!/bin/bash
# basic_ddos_protection.sh

MAX_REQUESTS_PER_MINUTE=100
LOG_FILE="/var/log/nginx/access.log"

echo "=== IP-адреса с подозрительной активностью ==="

# Анализ запросов за последнюю минуту
for ip in $(awk -vDate=$(date -d 'now - 1 minutes' +[%d/%b/%Y:%H:%M:%S) ' { if ($4 > Date) print $1 }' $LOG_FILE | \
sort | \
uniq -c | \
awk -v max=$MAX_REQUESTS_PER_MINUTE '$1 > max {print $2}'); do
    
    echo "Блокируем IP: $ip"
    
    # Добавляем в iptables (если используем)
    iptables -A INPUT -s $ip -j DROP 2>/dev/null
    
    # Или добавляем в nginx blacklist
    echo "deny $ip;" >> /etc/nginx/conf.d/blacklist.conf
done

# Перезагружаем nginx если изменился blacklist
if [ -f /etc/nginx/conf.d/blacklist.conf ]; then
    nginx -t && systemctl reload nginx
fi
```

## Настройка веб-сервера для оптимальной параллельной работы

### Для Nginx:

```bash
# /etc/nginx/nginx.conf
worker_processes auto;  # автоматическое определение по количеству CPU ядер
worker_connections 1024;  # соединений на worker
multi_accept on;  # принимать несколько соединений одновременно
use epoll;  # эффективный метод для Linux

# Кэширование для статики
open_file_cache max=1000 inactive=20s;
open_file_cache_valid 30s;
```

### Для Apache:

```bash
# /etc/apache2/mods-available/mpm_prefork.conf
<IfModule mpm_prefork_module>
    StartServers            5
    MinSpareServers         5
    MaxSpareServers         10
    MaxRequestWorkers       100
    MaxConnectionsPerChild  1000
</IfModule>
```

## Ключевые метрики для мониторинга веб-сервера

```bash
# Доступность
curl -I http://localhost 2>/dev/null | head -1

# Время ответа
time curl -s -o /dev/null http://localhost

# Количество процессов
ps aux | grep nginx | grep -v grep | wc -l

# Использование памяти процессами
ps -o pid,user,%mem,command ax | grep nginx | sort -b -k3 -r
```

## Распространенные проблемы и решения

### Проблема: "502 Bad Gateway"

**Решение:** Проверить backend services (PHP-FPM, application servers)

```bash
# Проверка PHP-FPM
systemctl status php7.4-fpm
netstat -tulpn | grep :9000
```

### Проблема: "Too many open files"

**Решение:** Увеличить лимиты файловых дескрипторов

```bash
# Текущие лимиты
ulimit -n

# Увеличение лимитов
echo "nginx soft nofile 65536" >> /etc/security/limits.conf
echo "nginx hard nofile 65536" >> /etc/security/limits.conf
```

### Проблема: Высокая загрузка CPU

**Решение:** Оптимизировать конфигурацию, кэширование

## Итог для системного администратора

**Веб-сервер — это идеальный пример параллельной системы**, где:

1. **Master process** управляет множеством **worker processes**

2. **Каждый worker** обрабатывает запросы независимо

3. **Параллелизм** позволяет обслуживать тысячи клиентов одновременно

**Сильный системный администратор умеет:**

- Настраивать веб-сервер для оптимальной параллельной работы

- Мониторить производительность и доступность

- Автоматически реагировать на проблемы

- Анализировать логи для выявления узких мест

- Защищать веб-сервер от атак и перегрузок

**Главный принцип:** Веб-сервер должен эффективно распределять работу между процессами/потоками, чтобы ни один клиент не ждал дольше необходимого, а системные ресурсы использовались оптимально.


