## Что такое сервисные пользователи?

**Сервисные пользователи** — это специальные системные учетные записи, созданные для запуска и управления конкретными службами или приложениями. Они не предназначены для интерактивного входа в систему и имеют минимально необходимые права.

### Аналогия (как для охраны объекта):

- **root** — главный начальник охраны (имеет ключи от всех помещений)

- **Обычные пользователи** — сотрудники (имеют ключи от своих кабинетов)

- **Сервисные пользователи** — специализированные работники:

    - **Уборщик** — имеет ключи только от кладовок с инвентарем

    - **Системный администратор** — имеет ключи от серверной

    - **Бухгалтер** — имеет ключи от архива документов

## Зачем нужны сервисные пользователи?

### 1. **Безопасность (принцип наименьших привилегий)**

```bash
# ПЛОХО: Запуск веб-сервера от root
sudo nginx  # если найдут уязвимость в nginx - взломан весь сервер

# ХОРОШО: Запуск от специального пользователя
sudo -u nginx nginx  # уязвимость в nginx - ограниченный ущерб
```

### 2. **Изоляция сервисов**

Каждый сервис работает в своей "песочнице" и не может повлиять на другие сервисы.

### 3. **Упрощение аудита и мониторинга**

Легко отслеживать, какие действия выполняет каждый сервис.

## Как выглядят сервисные пользователи в системе?

### Просмотр сервисных пользователей:

```bash
# Все пользователи системы
cat /etc/passwd

# Типичные сервисные пользователи (обычно с UID < 1000)
awk -F: '$3 < 1000 {print $1 " " $3 " " $6 " " $7}' /etc/passwd
```

```text
root 0 /root /bin/bash
daemon 1 /usr/sbin /usr/sbin/nologin
bin 2 /bin /usr/sbin/nologin
sys 3 /dev /usr/sbin/nologin
www-data 33 /var/www /usr/sbin/nologin
mysql 999 /var/lib/mysql /bin/false
nginx 998 /var/lib/nginx /bin/false
postgres 102 /var/lib/postgresql /bin/bash
```

### Характеристики сервисных пользователей:

- **UID**: обычно между 1-999 (системные пользователи)

- **Домашняя директория**: часто `/var/lib/сервис` или `/nonexistent`

- **Оболочка**: `/usr/sbin/nologin` или `/bin/false` (запрещает вход)

## Практическая работа с сервисными пользователями

### Создание сервисного пользователя:

```bash
# Стандартный способ
sudo useradd -r -s /bin/false -d /var/lib/myapp myapp_user

# С объяснением опций:
# -r: создать системного пользователя
# -s /bin/false: запретить вход в систему
# -d /var/lib/myapp: домашняя директория
# myapp_user: имя пользователя

# Альтернатива с adduser (в Debian/Ubuntu)
sudo adduser --system --no-create-home --disabled-login myapp_user
```

### Настройка прав для сервисного пользователя:

```bash
# Создаем директорию для данных приложения
sudo mkdir -p /var/lib/myapp
sudo chown myapp_user:myapp_user /var/lib/myapp
sudo chmod 750 /var/lib/myapp

# Даем права на запись в лог-директорию
sudo mkdir -p /var/log/myapp
sudo chown myapp_user:myapp_user /var/log/myapp
```

### Запуск службы от сервисного пользователя:

```bash
# Вручную
sudo -u myapp_user /usr/bin/myapp

# В systemd service файле
sudo nano /etc/systemd/system/myapp.service
```

**Пример systemd service файла:**

```ini
[Unit]
Description=My Application Service
After=network.target

[Service]
Type=simple
User=myapp_user
Group=myapp_user
ExecStart=/usr/bin/myapp
WorkingDirectory=/var/lib/myapp
Restart=on-failure

# Безопасность - ограничиваем возможности
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=strict
ProtectHome=yes

[Install]
WantedBy=multi-user.target
```

## Распространенные сервисные пользователи и их назначение

### Веб-серверы:

```bash
# Apache (Debian/Ubuntu)
ps aux | grep apache
# www-data - основной пользователь Apache

# Nginx
ps aux | grep nginx  
# nginx или www-data - пользователь Nginx

# Зачем: ограничить доступ к файлам вне веб-директории
```

### Базы данных:

```bash
# MySQL/MariaDB
ps aux | grep mysql
# mysql - пользователь СУБД

# PostgreSQL  
ps aux | grep postgres
# postgres - пользователь СУБД

# Зачем: изолировать доступ к файлам базы данных
```

### Другие сервисы:

```bash
# Docker
ps aux | grep docker
# docker - пользователь докера

# Redis
ps aux | grep redis
# redis - пользователь Redis

# Elasticsearch
ps aux | grep elasticsearch
# elasticsearch - пользователь Elasticsearch
```

## Практические сценарии для системного администратора

### Сценарий 1: Создание безопасного сервиса с нуля

```bash
#!/bin/bash
# setup_secure_service.sh

SERVICE_NAME="my_custom_app"
SERVICE_USER="${SERVICE_NAME}_user"
SERVICE_GROUP="${SERVICE_NAME}_group"

echo "=== Создание безопасного сервиса $SERVICE_NAME ==="

# Создаем сервисного пользователя и группу
sudo groupadd -r $SERVICE_GROUP
sudo useradd -r -s /bin/false -d /var/lib/$SERVICE_NAME \
    -g $SERVICE_GROUP $SERVICE_USER

# Создаем необходимые директории
sudo mkdir -p /var/lib/$SERVICE_NAME
sudo mkdir -p /var/log/$SERVICE_NAME
sudo mkdir -p /etc/$SERVICE_NAME

# Настраиваем права
sudo chown -R $SERVICE_USER:$SERVICE_GROUP /var/lib/$SERVICE_NAME
sudo chown -R $SERVICE_USER:$SERVICE_GROUP /var/log/$SERVICE_NAME
sudo chmod 750 /var/lib/$SERVICE_NAME /var/log/$SERVICE_NAME

# Копируем конфигурацию
sudo cp $SERVICE_NAME.conf /etc/$SERVICE_NAME/
sudo chown root:$SERVICE_GROUP /etc/$SERVICE_NAME/$SERVICE_NAME.conf
sudo chmod 640 /etc/$SERVICE_NAME/$SERVICE_NAME.conf

echo "Сервисный пользователь $SERVICE_USER создан"
echo "Директории настроены с правильными правами"
```

### Сценарий 2: Аудит сервисных пользователей

```bash
#!/bin/bash
# audit_service_users.sh

echo "=== Аудит сервисных пользователей ==="

# Пользователи с UID < 1000 (системные)
echo "Системные пользователи (UID < 1000):"
awk -F: '$3 < 1000 {printf "%-15s UID:%-5s Shell:%-15s Home:%s\n", $1, $3, $7, $6}' /etc/passwd

echo -e "\nПроцессы, запущенные от сервисных пользователей:"
ps aux | awk '$1 != "root" && $1 != "$USER" && $3 > 0.0 {print $1, $2, $11}' | \
head -10

echo -e "\nСервисные пользователи с активными процессами:"
ps -eo user= | sort | uniq | while read user; do
    if id "$user" &>/dev/null && [ "$user" != "root" ] && [ "$user" != "$USER" ]; then
        shell=$(getent passwd "$user" | cut -d: -f7)
        if [ "$shell" = "/usr/sbin/nologin" ] || [ "$shell" = "/bin/false" ]; then
            count=$(ps -u "$user" | wc -l)
            if [ $count -gt 1 ]; then
                echo "Пользователь: $user, Процессов: $((count-1))"
            fi
        fi
    fi
done
```

### Сценарий 3: Миграция сервиса с root на сервисного пользователя

```bash
#!/bin/bash
# migrate_service_to_user.sh

SERVICE="old_service"
NEW_USER="service_user"

echo "=== Миграция сервиса $SERVICE с root на $NEW_USER ==="

# Останавливаем сервис
sudo systemctl stop $SERVICE

# Создаем сервисного пользователя (если не существует)
if ! id "$NEW_USER" &>/dev/null; then
    sudo useradd -r -s /bin/false -d /var/lib/$SERVICE $NEW_USER
fi

# Изменяем владельца файлов
sudo chown -R $NEW_USER:$NEW_USER /var/lib/$SERVICE
sudo chown -R $NEW_USER:$NEW_USER /var/log/$SERVICE
sudo chown -R $NEW_USER:$NEW_USER /var/run/$SERVICE

# Обновляем systemd service файл
sudo sed -i "s/^User=.*/User=$NEW_USER/" /etc/systemd/system/$SERVICE.service
sudo sed -i "s/^Group=.*/Group=$NEW_USER/" /etc/systemd/system/$SERVICE.service

# Перечитываем конфигурацию и запускаем
sudo systemctl daemon-reload
sudo systemctl start $SERVICE

echo "Миграция завершена. Проверяем:"
ps aux | grep $SERVICE | head -5
```

### Сценарий 4: Экстренное вмешательство при компрометации

```bash
#!/bin/bash
# emergency_service_lockdown.sh

COMPROMISED_USER="$1"

echo "=== Экстренная блокировка пользователя $COMPROMISED_USER ==="

if [ -z "$COMPROMISED_USER" ]; then
    echo "Укажите пользователя: $0 <username>"
    exit 1
fi

# Завершаем все процессы пользователя
echo "Завершаем процессы пользователя $COMPROMISED_USER..."
sudo pkill -9 -u $COMPROMISED_USER
sleep 2

# Блокируем пользователя
echo "Блокируем учетную запись..."
sudo usermod -L $COMPROMISED_USER
sudo chsh -s /bin/false $COMPROMISED_USER

# Анализируем активность
echo "Анализ последних действий:"
sudo last -x | grep $COMPROMISED_USER | head -10

echo "Открытые файлы (если остались процессы):"
sudo lsof -u $COMPROMISED_USER 2>/dev/null | head -10

echo "Блокировка завершена. Проведите детальный анализ!"
```

## Мониторинг сервисных пользователей

### Постоянный мониторинг:

```bash
# Скрипт для мониторинга необычной активности сервисных пользователей
#!/bin/bash
# monitor_service_users.sh

# Сервисные пользователи не должны иметь интерактивные сессии
echo "=== Проверка интерактивных сессий сервисных пользователей ==="
who | awk '$1 != "root" {print $1}' | while read user; do
    shell=$(getent passwd "$user" | cut -d: -f7)
    if [ "$shell" = "/usr/sbin/nologin" ] || [ "$shell" = "/bin/false" ]; then
        echo "ПРЕДУПРЕЖДЕНИЕ: Сервисный пользователь $user имеет активную сессию!"
    fi
done

# Мониторинг необычных процессов от сервисных пользователей
echo "=== Необычные процессы от сервисных пользователей ==="
ps aux --sort=-%cpu | awk '$1 != "root" && $1 != "$USER" && $3 > 10.0 {print}'
```

## Итог для системного администратора

**Сервисные пользователи** — это критически важный механизм безопасности:

### Что нужно запомнить:

1. **Никогда не запускайте сервисы от root** без крайней необходимости

2. **Создавайте отдельного пользователя** для каждого сервиса

3. **Минимизируйте права** — давайте доступ только к необходимым ресурсам

4. **Запрещайте интерактивный вход** через `/usr/sbin/nologin` или `/bin/false`

5. **Используйте системы контроля доступа** like SELinux/AppArmor для дополнительной защиты

### Преимущества подхода:

- **Безопасность**: ограничение ущерба при компрометации

- **Стабильность**: изоляция сервисов друг от друга

- **Аудит**: четкое отслеживание действий каждого сервиса

- **Соответствие**: требованиям стандартов безопасности

**Правило большого пальца**: Если служба не требует прав root для своей работы, она должна работать под сервисным пользователем с минимально необходимыми привилегиями.