### **Что это?**

Сервисные пользователи — это **специальные системные аккаунты**, создаваемые автоматически при установке пакетов для безопасного выполнения системных служб (демонов) и приложений.

В вашем примере: `daemon`, `www-data`, `nobody`, `systemd-network`, `colord`, `libvirt-qemu` и т.д.

---
## **Зачем они нужны? (4 главные причины)**

### **1. Принцип минимальных привилегий (Security)**

Каждая служба получает **ровно столько прав, сколько ей нужно**:

- **Веб-сервер (www-data):** Может читать файлы в `/var/www/`, но не может читать `/home/` других пользователей

- **База данных (postgres):** Работает только со своими файлами БД

- **Принтеры (cups):** Доступ только к печати

**Без этого:** Если хакер взломает веб-сервер → получит доступ ко всей системе под пользователем `root`.

### **2. Изоляция служб (Isolation)**

Если падает/взламывается одна служба — другие защищены:

- **Взломали Redis (пользователь redis)** → не сможете прочитать конфиги PostgreSQL (пользователь postgres)

- **Утечка в Samba (пользователь smb)** → не затронет системные файлы

### **3. Контроль доступа к ресурсам (ACL)**

Файловая система Linux использует UID/GID для контроля:

```bash
# Посмотрим права на каталог веб-сервера
ls -la /var/www/
drwxr-xr-x  4 www-data www-data 4096 Dec 14 12:00 .
# Только www-data может записывать сюда
```

### **4. Отслеживание действий (Audit)**

В логах видно, кто что делал:

```bash
/var/log/auth.log: Dec 14 10:30:01 server sshd[1234]: Accepted password for www-data from 192.168.1.1
# Тревога! Веб-серверный аккаунт зашел по SSH!
```

---
## **Кто их создает и почему их так много?**

### **Создатели:**

1. **Пакетный менеджер** (apt, yum, pacman) при установке пакета

2. **Системные скрипты** при первой настройке

3. **Администратор** вручную для кастомных служб

### **Процесс создания (на примере установки nginx):**

```bash
# Устанавливаем
sudo apt install nginx

# Что происходит внутри пакета:
# 1. В pre-install скрипте:
groupadd --system nginx
useradd --system --no-create-home --shell /bin/false --gid nginx nginx

# 2. В post-install:
chown -R nginx:nginx /var/log/nginx
chmod 750 /var/log/nginx
```

### **Почему их десятки?**

- **Исторические:** Накопились за 30+ лет развития Linux

- **Модульность:** Каждый пакет отвечает за свою безопасность

- **Специализация:** Отдельный пользователь для каждой роли:

    - `dbus` — для межпроцессного взаимодействия
        
    - `systemd-timesync` — только для синхронизации времени
        
    - `redis` — только для Redis
        
    - И т.д.

---
## **Практика для администратора**

### **1. Идентификация "нормальных" vs "подозрительных" пользователей**

**Нормальные системные пользователи:**

- UID: 1-999 (системные), 65534 (nobody)
    
- Домашний каталог: `/nonexistent`, `/var/lib/*`, `/run/*`
    
- Оболочка: `/usr/sbin/nologin`, `/bin/false`
    
- Имена: начинаются с `_` или заканчиваются на `-d` (daemon)

```bash
# Фильтруем системных пользователей
awk -F: '$3 >= 1 && $3 <= 999 {print $1}' /etc/passwd
# Или по оболочке
grep -E '/nologin$|/false$' /etc/passwd | cut -d: -f1
```

**Тревожные признаки:**

```bash
# 1. Системный пользователь с bash оболочкой (кроме root)
grep -E ':/bin/(bash|sh|zsh)' /etc/passwd | grep -v '^root:'

# 2. Пользователь с UID 0 (второй root!)
grep ':x:0:' /etc/passwd

# 3. Неизвестные пользователи с высокими UID
awk -F: '$3 >= 1000 && $3 < 65000 {print $1 " (UID:" $3 ")"}' /etc/passwd
```

### **2. Аудит безопасности**

**Кто и когда заходил:**

```bash
# Проверяем логи входа
lastlog | grep -v "Never logged in"
grep "Accepted password" /var/log/auth.log | awk '{print $9}' | sort | uniq

# Смотрим активные процессы по пользователям
ps aux --sort=-user
```

**Проверка файлов, принадлежащих системным пользователям:**

```bash
# Найти все файлы, владельцем которых является системный пользователь
find / -uid 33 -ls 2>/dev/null  # www-data имеет UID 33
# Или для всех системных пользователей
for uid in $(awk -F: '$3 < 1000 {print $3}' /etc/passwd); do
    echo "=== UID $uid ==="
    find / -uid $uid -type f 2>/dev/null | head -5
done
```

### **3. Управление сервисными пользователями**

**Создание нового (правильный способ):**

```bash
# Для службы
sudo useradd --system --no-create-home --shell /usr/sbin/nologin my_service

# Для приложения
sudo useradd --system -m --home /opt/myapp --shell /bin/false myapp

# Проверяем
id my_service
# uid=998(my_service) gid=998(my_service) groups=998(my_service)
```

**Удаление (осторожно!):**

```bash
# 1. Сначала останавливаем службу
sudo systemctl stop my_service

# 2. Удаляем пользователя, но оставляем файлы
sudo userdel my_service

# 3. Или удаляем с файлами (опасно!)
sudo userdel -r my_service  # Только если уверены!
```

### **4. Мониторинг активности**

**Скрипт для проверки подозрительной активности:**

```bash
#!/bin/bash
# monitor_system_users.sh

echo "=== Системные пользователи с активными процессами ==="
for user in $(awk -F: '$3 < 1000 {print $1}' /etc/passwd); do
    count=$(ps -u $user | wc -l)
    if [ $count -gt 1 ]; then  # >1 потому что заголовок ps
        echo "$user: $((count-1)) процессов"
        ps -u $user -o pid,cmd --no-headers | head -3
    fi
done

echo -e "\n=== Последние логины системных пользователей ==="
lastlog | awk 'NR==1 || $2 !~ /Never/'
```

### **5. Реальные кейсы из практики**

**Кейс 1: Взлом через www-data**

```bash
# В логах увидели
# auth.log: www-data logged in via ssh

# Действия:
# 1. Немедленно блокируем
sudo passwd -l www-data
# 2. Ищем backdoor
find / -user www-data -perm /6000 2>/dev/null  # SUID/SGID файлы
find /var/www/ -name "*.php" -exec grep -l "eval\|base64_decode\|shell_exec" {} \;
# 3. Отключаем SSH для системных пользователей
echo "DenyUsers www-data" >> /etc/ssh/sshd_config
```

**Кейс 2: Утечка памяти у Redis**

```bash
# Redis (пользователь redis) съедает всю память
# Решение: ограничить через systemd
sudo systemctl edit redis.service
# Добавляем:
[Service]
MemoryMax=500M
MemorySwapMax=0
```

**Кейс 3: Служба требует много прав**

```bash
# Новая служба хочет работать от root
# Вместо этого:
# 1. Создаем отдельного пользователя
sudo useradd --system --no-create-home app_limited
# 2. Даем минимальные права
sudo setfacl -m u:app_limited:rx /usr/local/app
sudo setfacl -m u:app_limited:rw /var/log/app
# 3. Настраиваем службу
sudo systemctl edit app.service
# User=app_limited
# Group=app_limited
```

---
## **Важные правила для админа**

### **Никогда:**

1. **Не давайте системным пользователям shell /bin/bash**
    
2. **Не разрешайте им SSH доступ**
    
3. **Не используйте root для служб (кроме ядра/init)**
    
4. **Не удаляйте системных пользователей без понимания последствий**
    

### **Всегда:**

1. **Проверяйте** новых системных пользователей после `apt upgrade`
    
2. **Мониторьте** логи аутентификации
    
3. **Используйте отдельного пользователя** для каждой кастомной службы
    
4. **Документируйте** созданных вручную системных пользователей


### **Инструменты для работы:**

```bash
# Аудит
ausearch -m USER_LOGIN  # через auditd
logwatch --detail High  # ежедневный отчет

# Мониторинг
ps auxf                 # дерево процессов по пользователям
lsof -u www-data        # какие файлы открыл пользователь

# Безопасность
sudo find / -nouser -o -nogroup  # файлы без владельца
sudo passwd -S $(awk -F: '$3 < 1000 {print $1}' /etc/passwd)  # статус паролей
```

---
## **Вывод**

**Сервисные пользователи — это фундамент безопасности Linux.** Они превращают монолитную систему root-прав в **множество изолированных песочниц**. Современный админ должен:

1. **Понимать** их назначение
    
2. **Уметь** создавать и управлять ими
    
3. **Мониторить** их активность
    
4. **Использовать** для изоляции своих служб

40 пользователей в системе — это не "раздутость", а **признак правильно настроенной, безопасной системы**. Каждый лишний системный пользователь — это на один сервис меньше, работающего от root.