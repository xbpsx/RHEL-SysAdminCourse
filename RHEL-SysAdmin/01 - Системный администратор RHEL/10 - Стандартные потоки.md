Если у нас была бы программа, которая может складывать два числа, а другая только отнимать. Если нам нужно будет решить уравнение в котором нужно сначала сложить два числа, а потом из суммы отнять третье, то нам нужно выполнять первую программу, получить сумму и уже с этой суммой выполнить вторую программу, но было бы здорово, чтоб первая программа могла передать результат(сумму) второй программе без нашего участия, для этого, чтоб команды могли работать между собой в UNIX подобных системах, есть так называемые [[стандартные потоки]].

**Стандартный ввод** `stdin`
**Стандартный вывод** `stdout`
**Стандартный вывод ошибок** `stderr`

> Вообще эти потоки существуют независимот от того обьеденяете вы команды или нет. 

Первый поток `stind` это стандартный ввод, то есть то, откуда вводятся данные, например с клавиатуры. Мы обычно вводим какие-то данные в эмулятор терминала. 

Второй поток, `stdout` это то, что выводит команда, например, если мы пишем `ls` мы видим на экране информацию, вот, то, что появляется на экране, это и есть стандартный вывод. 

> `man cat` говорит, если запустить команду `cat` не указав файл, то по умолчанию он будет **копировать стандартный ввод в стандартный вывод**. Если мы ввели текст это `stdin`, а `cat` вывлет этот текст это `stdout`

Третий поток, `stderr` стандартный вывод ошибки. Многие программы под линукс заточены под то, что-бы реагировать на ошибки, отделять их от стандартного вывода. **Bash** видит `stdout` и `stderr` по разному, мы можем не заметить ошибку, но при выводе всех директорий, **bash** выводит ошибку о несуществующих

```bash
davidivashevich@fedora:~/Downloads$ mkdir dir1 dir3  
davidivashevich@fedora:~/Downloads$ ls dir1 dir 2 dir3  
ls: cannot access 'dir': No such file or directory  
ls: cannot access '2': No such file or directory  
dir1:  
  
dir3:  
davidivashevich@fedora:~/Downloads$
```

Теперь мы понимаем, что для того, что бы отправить результат первой программы сумму стандартного вывода, во вторую программу, где мы вручную должны были скопировать вывод программы во вторую программу. **Что-бы направлять потоки, нам нужны каналы.**

```text
a + b = c (stdout)
(stdin) c - d = e (stdout)
a + b -d = e (stdout)
```

> Мы можем управлять потоками, мы как администраторы можем это делать с помощью специальных символов.

![[Process_output_chaining_via_pipes.ru.svg.png]]

Эти символы как направление:

Символ у стандартного ввода `stdin <`
Символ у стандартного вывода `stdout >`
Символ стандартной ошибки `stderr 2>`

На примере программы mail, покажем примеры.

```bash
mail user < file.txt
```

Без использования перенаправления `stdin`, после того как мы нажмем **enter** мы должны будем написать письмо, а так мы команде `mail` **отправляем файл вместо ввода сообзщения на клавиатуре**, но в целом направление стандартного ввода используется гораздо реже, чем того же вывода. 

Для стандартного направления вывода мы используем `>`, мы можем направлять вывод не на экран, а в какой-нибудь текстовый файл. Например давайте перенаправим вывод команды `ls` в тектстовый файл

```bash
ls > file  

ls  
AlmaLinux-10.0-x86_64-minimal.iso   file Process_output_chaining_via_pipes.ru.svg.png  'Бункер (2025) WEB-DL 1080p.mkv'  

cat file  
AlmaLinux-10.0-x86_64-minimal.iso  
file  
Process_output_chaining_via_pipes.ru.svg.png  
Бункер (2025) WEB-DL 1080p.mkv  
```

Когда мы используем знак `>` то **содержимое файла перезаписывается**. Мы можем не перезаписывать файл, а добавлять в него текст, для этого мы можем использовать `>>` , например добавим в существующий файл, данные добавляся снизу и не перезапишутся. 

> `grep` **ищет все упоминания** `user` **в** `/etc/passwd` **и добавляет** `>>` **в наш текстовый** `file`

```bash
grep user /etc/passwd >> file

cat file
Desktop
Documents
Downloads
file
Music
Pictures
Public
Templates
Videos
chrony:x:996:996:chrony system user:/var/lib/chrony:/sbin/nologin
clevis:x:992:992:Clevis Decryption Framework unprivileged user:/var/cache/clevis:/usr/sbin/nologin
usbmuxd:x:113:113:usbmuxd user:/:/usr/sbin/nologin
qemu:x:107:107:qemu user:/:/usr/sbin/nologin
nm-openvpn:x:989:989:Default user for running openvpn spawned by NetworkManager:/:/usr/sbin/nologin
nm-openconnect:x:986:986:NetworkManager user for OpenConnect:/:/usr/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/usr/sbin/nologin
```

Для направления стандартного вывода ошибок используется `2>`. Например в этом выводе много ошибок доступа.

```bash
grep -rl bash /etc/
/etc/ImageMagick-7/mime.xml
grep: /etc/NetworkManager/system-connections/TP-Link_7B31.nmconnection: Permission denied
/etc/X11/xinit/xinitrc.d/10-qt5-check-opengl2.sh
/etc/X11/xinit/xinitrc.d/10-qt6-check-opengl2.sh
grep: /etc/audit: Permission denied
/etc/bash_completion.d/000_bash_completion_compat.bash
/etc/bash_completion.d/_python-argcomplete
/etc/bash_completion.d/audit.bash_completion
/etc/bash_completion.d/rpmdevtools.bash-completion
grep: /etc/credstore.encrypted: Permission denied
grep: /etc/credstore: Permission denied
/etc/cron.d/0hourly
grep: /etc/cups/ssl: Permission denied
grep: /etc/cups/classes.conf: Permission denied
grep: /etc/cups/cups-files.conf: Permission denied
grep: /etc/cups/cupsd.conf: Permission denied
grep: /etc/cups/printers.conf: Permission denied
grep: /etc/cups/cups-files.conf.default: Permission denied
grep: /etc/cups/cupsd.conf.default: Permission denied
grep: /etc/cups/snmp.conf.default: Permission denied
grep: /etc/cups/subscriptions.conf.O: Permission denied
grep: /etc/cups/subscriptions.conf: Permission denied
/etc/default/useradd
```

Мы можем **все ошибки перенаправить** в любой текстовой файл, например

```bash
grep -rl bash /etc/ 2> errors

cat errors
grep: /etc/NetworkManager/system-connections/TP-Link_7B31.nmconnection: Permission denied
grep: /etc/audit: Permission denied
grep: /etc/credstore.encrypted: Permission denied
grep: /etc/credstore: Permission denied
grep: /etc/cups/ssl: Permission denied
grep: /etc/cups/classes.conf: Permission denied
grep: /etc/cups/cups-files.conf: Permission denied
grep: /etc/cups/cupsd.conf: Permission denied
grep: /etc/cups/printers.conf: Permission denied
grep: /etc/cups/cups-files.conf.default: Permission denied
grep: /etc/cups/cupsd.conf.default: Permission denied
```

А в выводе будет только текст, но без ошибок. Если же текст ошибок нас не интересует, мыв можем направить их не в какой-нибудь текстовый файл, а в пустоту

```bash
grep -rl bash /etc/ 2> /dev/null
```

Так же, мы **можем разные потоки направлять в разные места**. Стандартный вывод в один файл, а стандартный вывод ошибок в другой.

```bash
grep -rl bash /etc/ > file 2> errors
```

В итоге у нас получится **два текстовых файла**

```bash
ls  
errors file

cat file

#покажет везде где упоминается bash
davidivashevich@fedora:~$ cat file
/etc/ImageMagick-7/mime.xml
/etc/X11/xinit/xinitrc.d/10-qt5-check-opengl2.sh
/etc/X11/xinit/xinitrc.d/10-qt6-check-opengl2.sh
/etc/bash_completion.d/000_bash_completion_compat.bash
/etc/bash_completion.d/_python-argcomplete
/etc/bash_completion.d/audit.bash_completion
/etc/bash_completion.d/rpmdevtools.bash-completion

cat errors

#покажет вывод ошибок

grep: /etc/NetworkManager/system-connections/TP-Link_7B31.nmconnection: Permission denied
grep: /etc/audit: Permission denied
grep: /etc/credstore.encrypted: Permission denied
grep: /etc/credstore: Permission denied
grep: /etc/cups/ssl: Permission denied
grep: /etc/cups/classes.conf: Permission denied
grep: /etc/cups/cups-files.conf: Permission denied
grep: /etc/cups/cupsd.conf: Permission denied
grep: /etc/cups/printers.conf: Permission denied
grep: /etc/cups/cups-files.conf.default: Permission denied
```

Если направить файл `stdout` то в командной строке будет виден `stderror`

```bash
mkdir dir1 dir3  
ls dir1 dir 2 dir3  
ls: cannot access 'dir': No such file or directory  
ls: cannot access '2': No such file or directory  
dir1:  
  
dir3:  
```

 Если направить `stderror`  то будет виден `stdout`, а если ничего не направлить мы увидим оба потока. А что делать, если сы хотим сохрнаить в файле и то и другое? для этого есть символ амперсанд `&>`

```bash
ls dir1 dir2 dir3 &> file
```

---
Тут мы направляем потоки в файлы 

```text
a + b = c (stdout)
(stdin) c - d = e (stdout)
a + b -d = e (stdout)
```

А в уровнение нам нужно направить `stdout` в `stdin` для этого используется другой смимвол `|` пайп (то есть труба)

```bash
stdout > stdin - |
```

Сначала мы получим стандартный вывод `stdout` команды `grep` и превратили его в стандартный ввод `stdin` команде `tail`

`stdout | stdin` вывод команды grep | вход команде tail

```bash
grep user /etc/passwd  
chrony:x:996:996:chrony system user:/var/lib/chrony:/sbin/nologin  
clevis:x:992:992:Clevis Decryption Framework unprivileged user:/var/cache/clevis:/usr/sbin/nologin  
usbmuxd:x:113:113:usbmuxd user:/:/usr/sbin/nologin  
qemu:x:107:107:qemu user:/:/usr/sbin/nologin  
nm-openvpn:x:989:989:Default user for running openvpn spawned by NetworkManager:/:/usr/sbin/nologin  
nm-openconnect:x:986:986:NetworkManager user for OpenConnect:/:/usr/sbin/nologin  
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/usr/sbin/nologin  

# Мы получим только 2 строкчи, что покажет grep
grep user /etc/passwd | tail -2  
nm-openconnect:x:986:986:NetworkManager user for OpenConnect:/:/usr/sbin/nologin  
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/usr/sbin/nologin  
```

```bash
head -9 /etc/passwd  
root:x:0:0:Super User:/root:/bin/bash  
bin:x:1:1:bin:/bin:/usr/sbin/nologin  
daemon:x:2:2:daemon:/sbin:/usr/sbin/nologin  
adm:x:3:4:adm:/var/adm:/usr/sbin/nologin  
lp:x:4:7:lp:/var/spool/lpd:/usr/sbin/nologin  
sync:x:5:0:sync:/sbin:/bin/sync  
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown  
halt:x:7:0:halt:/sbin:/sbin/halt  
mail:x:8:12:mail:/var/spool/mail:/usr/sbin/nologin  

head -9 /etc/passwd | tail -1  
mail:x:8:12:mail:/var/spool/mail:/usr/sbin/nologin  
davidivashevich@fedora:~$
```

---
Мы хотим вывести строчку с 5 по 25 и среди них найти слово user и сохранить это в файле

```bash
# С помощью tail выводим все, что ниже 5 строки
tail -n +5 /etc/passwd

# Далее из полученого вырежаем паервые 20 строчек
tail -n +5 /etc/passwd | head -20

# Далее с помощью grep ищем user и направляем в файл
tail -n +5 /etc/passwd | head -20 | grep user > file
```

Если мы хотим, чтоб результат **одновременно вводился в командную строку и записывался в файл**

```bash
tail -n +5 /etc/passwd | head -20 | grep user | tee file
```










