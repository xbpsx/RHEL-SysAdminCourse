Обычно процессы появляются, делают свою работу и завершаются, не требуя никакого внимания. Но бывают случаи когда администратору все же следует вмешатся. Давайте разберем, пару таких ситуаций.

Самая популярная, **зависает процесса или системы**. Все сталкивались когда некий процесс потребляет слишком **много оперативнйо памяти** или ресурсов процессора, это приводит к тому, что каким-то другим процессом той же оболочки перестает хватить ресурсов и все начинает **зависать**. Чтобы решить проблему, сначало нужно понять, **какой процесс во всем виноват.** Для этого стоит увидеть список процессов которые используют большую часть ресурсов. Это нам покажет утилита `top`

![[Screenshot From 2025-11-27 18-53-19.png]]
_Наверху отображается общая информация о системе_

Давайте пройдем по каждому из значений.

---

**Первая строчка** вывод утилиты `uptime` . 

```text
top - 18:55:21 up  5:01,  2 users,  load average: 0.42, 0.72, 0.75
```

- **18:55:21** - текущее время
- **5:01** - сколько система включена
- **2 user** - кол-во залогенненых сессий

Что бы увидеть пользователей, есть утилита `w`

```bash
davidivashevich@fedora:~$ w
 18:58:29 up  5:04,  2 users,  load average: 0.72, 0.72, 0.74
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
davidiva tty2      13:54    8:04m  0.05s  0.03s /usr/libexec/gnome-session-init-worker gnome
davidiva           13:54    3:33   0.00s  4.34s /usr/lib/systemd/systemd --user --deserialize=10
```

- **load average: 0.42, 0.72, 0.75** - среднее значение загрузки системы.

---

**Вторая строчка,** инфоромация о кол-во процессов

```bash
Tasks: 467 total,   2 running, 464 sleeping,   0 stopped,   1 zombie
```

- **467 total** -  сколько всего процессов
- **2 running** - сколько процессов выполняется сейчас
- **464 sleeping** - сколько процессов в ожидание(спят)
- **0 stopped** - сколько процессов остановлено, процессы можно останавливать, в этот момент они находятся в оперативнйо памяти, но перестают посылать код на процессор, просто ничего не делают.
- **1 zombie** - сколько зомби процессов. Когда один процесс, запускает другой, то для него он является родителем, а запущенный дочерним. Когда процесс дочерний выполнит свой процесс, он умирает дерожа в руках табличку со статусом заврешения, такой процесс наызвается зомби. При этом, родительский процесс должен прочитать эту табличку, отьпустив зомби процесс с покоем. Зомби процессы не используют никаких процессов, просто пока родитель не прочтет статус, они еще все числятся в таблице процессов.

**Количество процессов в таблице ограниченно**, для 32-битных систем максимальнео может быть примерно 32000 записей, а для 64-битных 4000000 записей. Увидеть текущий максимум можно командой:

```bash
davidivashevich@fedora:~$ cat /proc/sys/kernel/pid_max
4194304
```

Обычно для пользователей ставят **свое** **ограничение на количество процессов** , иожно увидеть командой

```bash
davidivashevich@fedora:~$ ulimit -u
126680
```

Ограничение пользователям ставится, чтоб один какой-то пользвоатель не забил всю таблицу, либо не запустил слишком много процессов. Когда таблица забита, например зомби процессами, то ничего сделат ьс системой не получится, потом-учто не получится создать новый процесс.

Чтобы пользователя огранчить на кол-во процессов, нужно в его файле `.bash_profile` выставить значение, например 

```bash
#.bash_profile

ulimit -u 1024
```

Но этот файл может редактировать пользваотель и если у нас много пользователей, или вы не доверяете ему, как прваильно выставляются огранчиения в `/etc/security/limits.conf`

Либо внутри директорий `/etc/security/limits.d` создается файл название которого заканчивается на `.conf`

Это все привинтивные меры которые защищают саму систему, но если же у какого то пользователя забилась таблица процессов и он не может запускать новые, **то нужно избавлятся от родительского процесса**. 

---

**Третья строчка**, информация использования процессора, информация отоброжается в процентах, по сути это процент времени который процессор, потратил на те или иные задачи в промежуток времени обновления информации в `top`

```text
%Cpu(s):  2.0 us,  2.9 sy,  0.0 ni, 93.1 id,  0.0 wa,  0.0 hi,  2.0 si,  0.0 st
```

По умолчанию это 3 секунды.

- **2.0 us** - это время потраченное на **userspace**(пользовательское пространство) речь идет о всех программах, кроме ядра(у ядра есть свое пространство **kernels**). То есть если взять веб сервер, то сама программа веб сервера, браузер, утилиты все это workspace, а ядро это **kernelspace**. Так, вот этот параметр показывает время выделенное процессором на userspace программы.
- **2.9 sy** - это время потраченное на **kernelspaces**.
- **0.0 ni** - это время потраченное на процессы с **низким приоритетом.**

> Для выставления приоритетов используется утилита `nice`  и числа от **-20 до 19**, чем выше значения, значит программа будет уступать свое время другим процессам, таким образом -20, это **наивысший приоритет**, приоритет по умолчанию 0.

```bash
xbpsx@debian:~$ nice
0
```

Более высокий приоритет, например -1,-2 **обычный пользователь не может задать**, а вот приоритет пониже можно. Запускаем firefox с приоритетом 5

```bash
nice -n 5 firefox
```

Что бы посмотреть теккущий приоритет

```bash
ps -el | head -5
```

```bash
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0       1       0  0  80   0 -  6279 -      ?        00:00:04 systemd
1 S     0       2       0  0  80   0 -     0 -      ?        00:00:00 kthreadd 
1 S     0       3       2  0  80   0 -     0 -      ?        00:00:00 pool_workqueue_release
1 I     0       4       2  0  60 -20 -     0 -      ?        00:00:00 kworker/R-kvfree_rcu_reclaim
```

Можно посмотреть запущенную нами firefox, приоритет будет в столбике **NI(nicec)**, а слева от него указан **PRI(приоритет)** и он отличается от того, что мы указали.

```bash
ps -el | grep firefox

0 S  1000    2935    1952  9  80   5 - 3072083 do_sys ?      00:08:32 firefox-esr
```

Это из-за того, что в `nice` мы указываем желаемый приортет для программы, но вовремя работы, но **ядро распределяет приоритеты по своей шкале**. 

> **PRI** - показывает приоритет в ядре, а **NI** показывает заданный приоритет

Если программа **уже запущена**, то ее вежливость можно изменить с помощью 

```bash
renice -n 10 firefox
```

Для **повышения** приоритета нужны права **суперпользователя(root)**

- **id** - от слова idol (время проведенная в ожидание)
- **wa** - времЯ потраченнео процессов на ожидание и **чтение или записи на диск**
- **hi** - **аппаратные прерывания**, когда жесткий диск или другая програпмма пытается процессору сообщить о каком то событие, она по слыает сигнал.
- **si** - время потрачное процессором на аппратаные прерывания
- **st** - этот парамент отнсоится к виртуальным машинам, какое время ренальный процессор был недоступен виртуальной машине(был занят гипервизором или др)

---

**Четвертая строчка**, про **оперативную память**

```text
MiB Mem :  31952.6 total,  22252.4 free,   5407.1 used,   4850.0 buff/cache 
```

- **31952.6 total** - сколько всего оперативной памяти (31GB)
- **22252.4 free** - сколько свободного памяти (22GB)
- **5407.1 used** - сколько используется(5.4GB)
- **4850.0 buff/cache** - место используемая для кэша

Мы можем **ограничить количество виртуальной памяти** выделяемую каждому процессу.

```bash
ulimit -v 10000
```

Либо записываем в по пути со своим значением в с параметром **as**

```bash
cd /etc/security/limits.conf
```

---
**Пятая строчка**, это **swap**

```bash
MiB Swap:  ,  32551.0 free,      0.0 used.  28837.3 avail Mem 
```

- **32551.0 free** - свободно swap (32GB)
- **0.0 used** - сколько используется

---



