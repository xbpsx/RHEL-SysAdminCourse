
[[#top]]
[[#htop]]

---
## top

Давайте разберем идентификаторы процессов в утилите `top`

```
PID USER   PR  NI    VIRT    RES    SHR S  %CPU  %MEM  TIME+   COMMAND 
```

| Идентификатор | Значение                                                        |
| ------------- | --------------------------------------------------------------- |
| [[PID]]       | Идентификатор процесса                                          |
| [[USER]]      | Пользователь запустивший процесс                                |
| [[PR]]        | Текущий приоритет в ядре                                        |
| [[NI]]        | Вежлиовсть процессов                                            |
| [[VIRT]]      | Виртуальная память                                              |
| [[RES]]       | Сколько реальной оперативной памяти использует процесс          |
| [[SHR]]       | Сколько виртуальной памяти может разделено с другими процессами |
| [[S]]         | Статус процесса                                                 |
| [[%CPU]]      | Использование процессора в процентах                            |
| [[%MEM]]      | Значение как RES,  показывает %  от всей оператитвной памяти    |
| [[TIME+]]     | Сколько времени процессор работал над этим процессом            |
| [[COMMAND]]   | Команда которая запустила процесс                               |
У `PR` иногда вместо цифр написано **rt(real time)** , это озночает, что ОС будет такой процесс выполнять моменально. Как правило, это процессы **работающие с оборудованием**.

Мы говорили, что при запске для процесса создается иллюзия, что этот процесс единственный в оперативной памяти, это осуществляется за счет того, что для каждого процесса создается [[адресное пространство]] `VIRT`

![[Screenshot From 2025-12-14 19-55-42.png]]

> У разных процессов адреса могут совпадать, но данные в них разные. Эти адреса ядро ОС связывает где-то с физическими адресами в оперативной памяти, где то со swap на диске, а где то с большим файлами на диске которая система не загружает в оперативку. 

И вот все эти адреса для процессов находятся в одном листе(лист это аналогия, а на деле называется адресным пространством)

*Утилиту top можно перенастроить, что бы она показывала другие столбцы*

---
В утилите `top` нас интересует 3 паарметра, это **%CPU, PID, %MEM**.

### Быстрые команды в top:

- `Shift + M` — сортировка по памяти (%MEM)

- `Shift + P` — сортировка по CPU (по умолчанию)

- `c` — показать полную командную строку

- `k` — убить процесс (запросит PID)

- `r` — изменить приоритет (renice)

- `z` — цветное/чёрно-белое отображение

- `1` — показать нагрузку на каждое ядро CPU

- `Shift+<` или `Shift+>` — сортировка по другой колонке

---
# htop

![[Screenshot From 2025-12-14 21-03-59.png]]

```bash
kill
```

Позволяет нам посылать сигналы, в основном, что бы **убиваить процессы.** 

```bash
ps -ef | grep gnome-text-editor
xbpsx      16859   16199  5 21:09 pts/0    00:00:02 gnome-text-editor
xbpsx      16978   16903  0 21:10 pts/1    00:00:00 grep gnome-text-editor
```

Убиваем процесс

```bash
kill 16850
```

Список сигналов

```bash
kill -l
```

```text
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 2) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
3) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
4) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
5) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
6) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
7) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
8) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
9) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
10) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
11) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
12) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
13) SIGRTMAX-1	64) SIGRTMAX
```

Когда мы написали `kill pid` мы послали **сигнал по умолчанию** 15 сигнал **(SIGTERM)** , это мягкий сигнал  который дает процессу время закончить свои дела прежде чем умереть. За это время, процесс успевает попрощаться с родительскими и дочерними процессами. После смерти процесса, его дочерние процессы становятся процессами сиротами и у них появляется нвоый родитель, процесс `init 1`  **systemd** 

Когда мы посылаем **SIGTERM** процесс сам отвечает за свое завершение. Но, что если процесс **завис?** *В таких ситуациях лучше разобраться с чем это связано.* Но, есть способ **принудительно завершить** процесс, использовать 9 сигнал **(SIGRTMIN+9)**, но это опасный сигнал, резкое убийство процесса, без возможности завершить дела, может повредить БД, файловую систему и тд.

```bash
kill -9 5709
```

_Лучше найти причину проблемы, чем убиваать процесс сигналом -9_

Можно, вместо номеров использовтаь название сигналов

```bash
kill -SIGKILL 5709
```

Большинство сигналов нужны, не столько администратором, сколько разработчкам. Но есть парочку для сис админа, например **SIGSTOP** 19

Чтобы постоянно не искать id процесса, мы можем использовать команду `pkill`, она сама **ищет процесс по шаблону** 

```bash
pkill -19 gnome-text-editor
```

Но нужно быть осторжным, в некоторых случаев у разных процессов могут совпдать имена. Теперь блокнот ни на,что не регаирует, если мы хотим, чтоб он продолжил работать посылаем сигнал **SIGCONT** 18

```bash
pkill -18 gnome-text-editor
```

_Блокнот продолжает работать,


Когда у нас зависает система , смотрим` top` или `htop` , сортируем и решаем, что делать с процессом. 

---

> Например, у нас шел бэкап БД на внешний сервер, а он отвалился от сети и теперь БД начала грузить процессы, легче всего будет вернуть работу бэкап сервер

Если у нас зависает графический интерфейс, попробуем открыть **tty**. 

Если ваша система **намертво зависает** и не реагирует ни на что, зачастую это из-за **нехватки памяти**, может быть, что какой-то багованый софт сьель всю оперативную память, от чего система зависла, это называется [[oom-out of memory]] , но это все привинтивные меры , можно пробовать мгический `SysRq`  это клавиша `PrnScr`  эта клавиша позволяет посылать какие-то команды к ядру, напмример что-бы решить проблему `OOM`  стоит нажать `ALT+PrnScr+F` тогда ядро избавится от менее значемых процессов, что-бы освободить память 

