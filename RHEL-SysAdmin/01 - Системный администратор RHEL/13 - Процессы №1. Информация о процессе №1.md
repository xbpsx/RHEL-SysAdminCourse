Как мы выяснили программы хранятся в файловой система на накопителе, то есть **на жестком диске или SSD**, когда мы запускаем программу, она загружается в [[оперативную память]], так как скорость чтения жесткого диска или даже SSD относительно низкое, а **процессор работает на больших скоростях**. 

Как правило большие программы загружаются в оперативную память не полностью, а по мере необходимости. При этом для каждой прогрммы создается иллюзия, что она единственная в оперативной памяти. То есть для нее создается так называемая [[виртульная память]]. Так же программа при запуске загружает какие то файлы, будь то файлы настроек или пользовательские файлы, как например если мы запускаем `nano file` то в память загружается, как сам `/usr/bin/nano`, его настройки `/etc/nanorc` и `~/.nanorc` всякие бибилиотеки необходимые для работы `nano` и сам файл который мы открываем.

> **Когда запускаешь** `nano file.txt`, редактор (обычно `/usr/bin/nano`) проверяет и **загружает системный конфиг** `/etc/nanorc` (глобальные настройки: syntax highlighting, binds, цвета), а потом **переопределяет их пользовательским** `~/.nanorc` (или `~/.config/nano/nanorc` в новых версиях, **где можно кастомить клавиши, softwrap, mouse support**). Если файлов нет, nano работает с дефолтами; плюс, он использует библиотеки вроде `ncurses` (для терминальной отрисовки), `libmagic` (для MIME-определения типа файла и подсветки) и DBus (если включишь, для интеграции с DE вроде GNOME). Ещё: создаёт/читает буфер в RAM (до 1GB+ по умолчанию), логирует историю поиска/undo в `~/.nano_history` (если enabled), и опции командной строки (типа -l для номеров строк) переопределяют конфиги.

Кроме этого, так же запускаемой программе **передается переменное окружение** и многое другое. Программа находясь в оперативной памяти делает вычисления с помощью [[центрального процессора]], обрабатывает данные и сохроняет на диске. Совокупность всего этого называется [[процессом]] . 

Иногда одной программе нужно выполнить несколько операций параллельно. Представьте себе, сложное математическое уравнение, есть скобки, умножение и прочее. Такое уровнение можно разделить на составляющие и ПК может разом выполнить все по частям, а потом используя результаты, получить простое уровнение и выполнить его. Или допустим, [[веб-сервер]] 

![[basic_static_app_server.png]]

К нему обращается много клиентов и каждого из них он должен обслужить,и желательно паралельно. Для этого один процесс может разделяться на так называемые [[потоки]] , все они используют [[общую виртуальную память]]. У каждого [[процесса есть как минимум один поток]] 

И так, выполняемая программа - **это процесс**. Начнем с того, что администратору важно видеть **список процессов**. Для этого есть несколько способов.

---
### ps

Начнем с утилиты `ps`, если мы просто запустим `ps`, мы увидим список процессов запущенных в этом терминале.

```bash
 ps
   PID TTY          TIME CMD
   8857 ?        00:00:00 bash
   8892 ?        00:00:00 ps
```

Как мы заметили, вывелось две строчки. bash и ps, он **делает скриншот в момент выполнения.** Вообще `ps` работает с **тремя видами ключей**

- **UNIX** (юниксовыми), они начинаются обычно на 1 дефис
- **BSD** вовсе без дефиса
- **GNU** как правило это слова, чтобы не спустать с комбинациями с букв, используется 2 дефиса

Все учить не нужно, достаочно выучить одну комбинацию `ps -ef` которая подойдет в большинстве случаев

```bash
ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 12:31 ?        00:00:01 /usr/lib/systemd/systemd --switched-root --system 
root           2       0  0 12:31 ?        00:00:00 [kthreadd]
root           3       2  0 12:31 ?        00:00:00 [pool_workqueue_release]
root           4       2  0 12:31 ?        00:00:00 [kworker/R-rcu_gp]
root           5       2  0 12:31 ?        00:00:00 [kworker/R-sync_wq]
root           6       2  0 12:31 ?        00:00:00 [kworker/R-kvfree_rcu_reclaim]
root           7       2  0 12:31 ?        00:00:00 [kworker/R-slub_flushwq]
root           8       2  0 12:31 ?        00:00:00 [kworker/R-netns]
root          10       2  0 12:31 ?        00:00:00 [kworker/0:0H-events_highpri]
root          13       2  0 12:31 ?        00:00:00 [kworker/R-mm_percpu_wq]
root          15       2  0 12:31 ?        00:00:00 [ksoftirqd/0]
root          16       2  0 12:31 ?        00:00:00 [rcu_preempt]
root          17       2  0 12:31 ?        00:00:00 [rcu_exp_par_gp_kthread_worker/0]
root          18       2  0 12:31 ?        00:00:00 [rcu_exp_gp_kthread_worker]
root          19       2  0 12:31 ?        00:00:00 [migration/0]
root          20       2  0 12:31 ?        00:00:00 [idle_inject/0]
...
```

Как видим, вывод у `ps` большой(обрезается), что-бы нормально его прочесть, мы можем передать вывод `ps` команде `less`

```bash
ps -ef | less

root           1       0  0 12:31 ?        00:00:01 /usr/lib/systemd/systemd --switched-root --system 
--deserialize=60 rhgb
root           2       0  0 12:31 ?        00:00:00 [kthreadd]
root           3       2  0 12:31 ?        00:00:00 [pool_workqueue_release]
root           4       2  0 12:31 ?        00:00:00 [kworker/R-rcu_gp]
root           5       2  0 12:31 ?        00:00:00 [kworker/R-sync_wq]
root           6       2  0 12:31 ?        00:00:00 [kworker/R-kvfree_rcu_reclaim]
root           7       2  0 12:31 ?        00:00:00 [kworker/R-slub_flushwq]
root           8       2  0 12:31 ?        00:00:00 [kworker/R-netns]
root          10       2  0 12:31 ?        00:00:00 [kworker/0:0H-events_highpri]
root          13       2  0 12:31 ?        00:00:00 [kworker/R-mm_percpu_wq]
root          15       2  0 12:31 ?        00:00:00 [ksoftirqd/0]
root          16       2  0 12:31 ?        00:00:01 [rcu_preempt]
root          17       2  0 12:31 ?        00:00:00 [rcu_exp_par_gp_kthread_worker/0]
root          18       2  0 12:31 ?        00:00:00 [rcu_exp_gp_kthread_worker]
root          19       2  0 12:31 ?        00:00:00 [migration/0]
root          20       2  0 12:31 ?        00:00:00 [idle_inject/0]
...
```

По умолчанию `less` переносит слвоа на новые строки из-за чего сбиваются столбцы, поэтому добавим ключ `-S`

```bash
ps -ef | less -S
```

Давайте разберемся, что такое **ключи и как читать вывод.** 

Ключ ps `-e` выведет **все процессы, всех пользователей**

```bash
ps -e  
   PID TTY          TIME CMD  
     1 ?        00:00:01 systemd  
     2 ?        00:00:00 kthreadd  
     3 ?        00:00:00 pool_workqueue_release  
     4 ?        00:00:00 kworker/R-rcu_gp  
     5 ?        00:00:00 kworker/R-sync_wq  
     6 ?        00:00:00 kworker/R-kvfree_rcu_reclaim  
     7 ?        00:00:00 kworker/R-slub_flushwq  
     8 ?        00:00:00 kworker/R-netns  
    10 ?        00:00:00 kworker/0:0H-events_highpri  
    13 ?        00:00:00 kworker/R-mm_percpu_wq  
    15 ?        00:00:00 ksoftirqd/0  
    16 ?        00:00:01 rcu_preempt  
    17 ?        00:00:00 rcu_exp_par_gp_kthread_worker/0  
    18 ?        00:00:00 rcu_exp_gp_kthread_worker  
    19 ?        00:00:00 migration/0  
    20 ?        00:00:00 idle_inject/0  
    21 ?        00:00:00 cpuhp/0  
    22 ?        00:00:00 cpuhp/1
...
```

Процессы запускаются от имени пользователей, от этого зависит **какие права будет у процесса**. Допустим, если я запускаю утилиту `nano` от пользователя **user**, то программа может **работать с моим файлами**. 

Ключ `-f` показывает чуть больше о процессе.

```bash
davidivashevich@fedora:~$ ps -f
UID          PID    PPID  C STIME TTY          TIME CMD
davidiv+   11929    5864  0 13:13 ?        00:00:00 /bin/bash
davidiv+   12475   11929 99 13:18 ?        00:00:00 ps -f
```

Давайте пройдемся, **по столбикам** 

```bash
UID          PID    PPID  C STIME TTY          TIME CMD
```

- **UID(user id)** - пользователь который запустил процесс. Большинство процессов в системе запущено от пользователя **root**, его так же называют **суперпользователем**. У рута есть все права на систему, по возможности люди **стараются не использовать root везде**, если у программы будет баг или уязвимость, и она будет запущена от рута, то программа навредит сильно системе. Поэтому для программ которые не требует особых прав, обычно создается [[сервисных пользователей]], как правило, при установке программы она все это сама настаривает. Ну и наконец, программа запущенная от нашего пользователя.
- **PID(process id)** - он уникальный для каждого процесса, но совпдает для **потоков** одного процесса. Когда программа завершается, она освобождает номер и через другое время, другая программа может занять этот номер. С помощью этих номеров, мы можем **управлять процессами**.
- **PPID(parent process ID)** - индефикатор родительского процесса. Почти все процессы в системе были запущеными каким-то другим процессом. Например, мы запускаем в эмуляторе терминала `nano`, родительским процессом для `nano` является **bash** (bin/bash)

```bash
davidivashevich@fedora:~$ ps -ef | grep nano
davidiv+   15556   15455  0 13:58 ?        00:00:00 grep --color=auto nano
davidivashevich@fedora:~$ ps -f 15455
UID          PID    PPID  C STIME TTY      STAT   TIME CMD
davidiv+   15455    5864  0 13:57 ?        Ss     0:00 /bin/bash
```

который был запущен в эмуляторе терминала. Родительским процессом для bash, является **GNOME-terminal**(однако у нас ptyxis-agent) 

```bash
davidivashevich@fedora:~$ ps -f 16160
UID          PID    PPID  C STIME TTY      STAT   TIME CMD
davidiv+   16160   16149  0 14:00 ?        Ssl    0:00 /usr/libexec/ptyxis-agent --socket-fd=3 --rlimit-nofile=1024
```

За последним родительском процессе стоит **systemd** **user**

```bash
davidivashevich@fedora:~$ ps -f 3560
UID          PID    PPID  C STIME TTY      STAT   TIME CMD
davidiv+    3560       1  0 12:31 ?        Ss     0:02 /usr/lib/systemd/systemd --user
```

Ну а для этого родитскльой процесс **systemd**

```bash
davidivashevich@fedora:~$ ps -f 1
UID          PID    PPID  C STIME TTY      STAT   TIME CMD
root           1       0  0 12:31 ?        Ss     0:01 /usr/lib/systemd/systemd --switched-root --system --deserialize=60 rhgb
```

- **C** - использования процессора данным процессом. Почти везде 0, но давайте запустим тяжелый прооцесс **firefox**, тут у него 8

```bash
davidiv+    6149    3850  8 12:33 ?        00:08:40 /usr/lib64/firefox/firefox
```

- **STIME** - время когда процесс был запущен. 
- **TTY** - Обычно процесс запущенный системой и не требующий графики выводы информации на экран, не связан ни с каким терминалом. Процессы требующие графики завязаны на каком то виртуальном терминале.
- **TIME** - это сколько времени потратил процессор с этим процессом. Многие процессы занимают 0. 
- **CMD** - это команда которая запустила процесс. Некоторые процессы в [] `ps`  не смог найти аргументы. **Обычно это процессы самого ядра.**

---
### procfs

Хранить информацию о процессах на жесктом диске нецелесообразно, какие то процессы существуют долесекунды, жесткий диск не подходит для такого, а вот в оперативной памяти информацию о процессах можно хранить и представлять в виде файлах, но раз речь идет о файлах, то нам нужна файловая система. Ядро создает виртуальную файловую систему, которая живет только в оперативной памяти. Вообще, этих виртуальных файловых систем несколько, они используются для разных задач. Но сейчас нас интеерсует файловая система [[procfs]], она примонтирована в директории `cd /proc` если посмотреть содержимсое этой директории, мы увидим кучу директорий и файлов. **Именно название директорий номера процессов** то есть **PID**

Ядро ОС генерирует эту информацию налету, стоит нам посмотреть, мы увидим актулаьную информацию. Вообще в этой директории, кроме директорйи процессов есть много других файлов. например  `version` показывает версию ядра.

```absh
davidivashevich@fedora:/proc$ cat version
Linux version 6.17.8-300.fc43.x86_64 (mockbuild@ab7cf9a033ee48b98a175e8677ed2d80) (gcc (GCC) 15.2.1 20251022 (Red Hat 15.2.1-3), GNU ld version 2.45-1.fc43) #1 SMP PREEMPT_DYNAMIC Fri Nov 14 01:47:12 UTC 2025
davidivashevich@fedora:/proc$ 
```

Или `uptime` показывает сколкьо секунд включена система

```bash
davidivashevich@fedora:/proc$ cat uptime
7162.98 81434.70
```

Давайте посмотрим, что в директориях процессов.  Найдем PID firefox

```bash
ps -ef | grep firefox
davidiv+   15569    6235  0 13:58 ?        00:00:01 /usr/lib64/firefox/firefox -contentproc -isForBrowser -prefsHandle 0:4383
```

И войдем в директорию `cd 6235`, эти файлы нужны, для программ. 

```bash
pwd
/proc/6235

avidivashevich@fedora:/proc/6235$ ls  
arch_status  comm                fdinfo             loginuid    net            patch_state  setgroups     syscall  
attr         coredump_filter     gid_map            map_files   ns             personality  smaps         task  
autogroup    cpu_resctrl_groups  io                 maps        numa_maps      projid_map   smaps_rollup  timens_offsets  
auxv         cwd                 ksm_merging_pages  mem         oom_adj        root         stack         timers  
cgroup       environ             ksm_stat           mountinfo   oom_score      sched        stat          timerslack_ns  
clear_refs   exe                 latency            mounts      oom_score_adj  schedstat    statm         uid_map  
cmdline      fd                  limits             mountstats  pagemap        sessionid    status        wchan  
```

Некоторые файлы, мы можем прочитать, например `cmdline` тут отоброжена **команда которая запустила процесс**

```bash
cat cdmline
/usr/lib64/firefox/firefox-contentproc-ipcHandle0-signalPipe1-initialChannelId{df830225-ed0a-4357-8412-10f6c97799ec}-parentPid6149-greomni/usr/lib64/firefox/omni.ja-appomni/usr/lib64/firefox/browser/omni.ja-appDir/usr/lib64/firefox/browser1forkserver
```





